using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace SharePointPnP.Modernization.Framework.Telemetry.Observers
{
    /// <summary>
    /// Markdown observer intended for end-user output
    /// </summary>
    public class MarkdownObserver : ILogObserver
    {

        // Cache the logs between calls
        private static readonly Lazy<List<Tuple<LogLevel,LogEntry>>> _lazyLogInstance = new Lazy<List<Tuple<LogLevel, LogEntry>>>(() => new List<Tuple<LogLevel, LogEntry>>());
        protected bool _includeDebugEntries;
        protected DateTime _reportDate;
        protected string _reportFileName = "";

        /// <summary>
        /// Constructor for specifying to include debug entries
        /// </summary>
        /// <param name="includeDebugEntries">Include Debug Log Entries</param>
        public MarkdownObserver(string fileName = "", bool includeDebugEntries = false)
        {
            _includeDebugEntries = includeDebugEntries;
            _reportDate = DateTime.Now;
            _reportFileName = fileName;

#if DEBUG && MEASURE && MEASURE
                _includeDebugEntries = true; //Override for debugging locally
#endif
        }


        #region Markdown Tokens
        private const string Heading1 = "#";
        private const string Heading2 = "##";
        private const string Heading3 = "###";
        private const string Heading4 = "####";
        private const string Heading5 = "#####";
        private const string Heading6 = "######";
        private const string UnorderedListItem = "-";
        private const string Italic = "*";
        private const string Bold = "__";
        private const string BlockQuotes = "> ";
        private const string TableHeaderColumn = "-------------";
        private const string TableColumnSeperator = " | ";
        private const string Link = "[{0}]({1})";
        #endregion

        /// <summary>
        /// Get the single List<LogEntry> instance, singleton pattern
        /// </summary>
        public static List<Tuple<LogLevel, LogEntry>> Logs
        {
            get
            {
                return _lazyLogInstance.Value;
            }
        }

        /// <summary>
        /// Debug level of data not recorded unless in debug mode
        /// </summary>
        /// <param name="entry"></param>
        public void Debug(LogEntry entry)
        {
            if (_includeDebugEntries)
            {
                Logs.Add(new Tuple<LogLevel, LogEntry>(LogLevel.Error, entry));
            }
        }

        /// <summary>
        /// Errors 
        /// </summary>
        /// <param name="entry"></param>
        public void Error(LogEntry entry)
        {
            Logs.Add(new Tuple<LogLevel, LogEntry>(LogLevel.Error, entry));
        }

        /// <summary>
        /// Reporting operations throughout the transform process
        /// </summary>
        /// <param name="entry"></param>
        public void Info(LogEntry entry)
        {
            Logs.Add(new Tuple<LogLevel, LogEntry>(LogLevel.Information, entry));
        }

        /// <summary>
        /// Report on any warnings generated by the reporting tool
        /// </summary>
        /// <param name="entry"></param>
        public void Warning(LogEntry entry)
        {
            Logs.Add(new Tuple<LogLevel, LogEntry>(LogLevel.Warning, entry));
        }

        /// <summary>
        /// Generates a markdown based report based on the logs
        /// </summary>
        /// <returns></returns>
        protected virtual string GenerateReport(bool includeHeading = true)
        {
            StringBuilder report = new StringBuilder();
            if (includeHeading)
            {
                report.AppendLine($"{Heading1} Modernisation Report");
                report.AppendLine();
            }

            // This could display something cool here e.g. Time taken to transform and transformation options e.g. PageTransformationInformation details
            var reportDate = _reportDate;
            var allLogs = Logs.OrderBy(l => l.Item2.EntryTime);

            report.AppendLine($"{Heading2} Transformation Details");
            report.AppendLine();
            report.AppendLine($"{UnorderedListItem} Report date: {reportDate}");
            var logStart = allLogs.FirstOrDefault();
            var logEnd = allLogs.LastOrDefault();

            if (logStart != default(Tuple<LogLevel,LogEntry>) && logEnd != default(Tuple<LogLevel, LogEntry>))
            {
                TimeSpan span = logEnd.Item2.EntryTime.Subtract(logStart.Item2.EntryTime);
                report.AppendLine($"{UnorderedListItem} Transform duration: {string.Format("{0:D2}:{1:D2}:{2:D2}", span.Hours, span.Minutes, span.Seconds)}");
            }

            var transformationSummary = allLogs.Where(l => l.Item2.Heading == LogStrings.Heading_Summary);

            foreach (var log in transformationSummary)
            {
                report.AppendLine($"{UnorderedListItem} {log.Item2.Message}");
            }

            #region Summary Page Transformation Information Settings

            report.AppendLine();
            report.AppendLine($"{Heading3} Page Transformation Settings");
            report.AppendLine();
            report.AppendLine($"Property {TableColumnSeperator} Setting");
            report.AppendLine($"{TableHeaderColumn} {TableColumnSeperator} {TableHeaderColumn}");

            var transformationSettings = allLogs.Where(l => l.Item2.Heading == LogStrings.Heading_PageTransformationInfomation);
            foreach (var log in transformationSettings)
            {
                var keyValue = log.Item2.Message.Split(new string[] { LogStrings.KeyValueSeperatorToken }, StringSplitOptions.None);
                if (keyValue.Length == 2) //Protect output
                {
                    report.AppendLine($" {keyValue[0] ?? ""} {TableColumnSeperator} {keyValue[1] ?? "<Not Set>"} ");
                }
            }

            #endregion

            report.AppendLine($"{Heading2} Transformation Operation Summary");
            report.AppendLine();

            #region Transformation Summary

            report.AppendLine($" Date {TableColumnSeperator} Operation {TableColumnSeperator} Actions Performed ");
            report.AppendLine($" {TableHeaderColumn} {TableColumnSeperator} {TableHeaderColumn} {TableColumnSeperator} {TableHeaderColumn} ");

            var logDetails = allLogs.Where(l => l.Item2.Heading != LogStrings.Heading_PageTransformationInfomation &&
                                            l.Item2.Heading != LogStrings.Heading_Summary);
            
            foreach (var log in logDetails.Where(l => l.Item1 == LogLevel.Information || l.Item1 == LogLevel.Warning))
            {
                if (log.Item1 == LogLevel.Information)
                {
                    report.AppendLine($" {log.Item2.EntryTime} {TableColumnSeperator} {log.Item2.Heading} {TableColumnSeperator} {log.Item2.Message} ");
                }
                else
                {
                    report.AppendLine($" {log.Item2.EntryTime} {TableColumnSeperator} {Bold}{log.Item2.Heading}{Bold} {TableColumnSeperator} {Bold}{Italic}{log.Item2.Message}{Italic}{Bold} ");
                }
            }

            #endregion

            if (logDetails.Any(l => l.Item1 == LogLevel.Error))
            {
                #region Report on Errors

                report.AppendLine($"{Heading3} Errors occurred during transformation");
                report.AppendLine();

                report.AppendLine($" Date {TableColumnSeperator} Operation {TableColumnSeperator} Error Message ");
                report.AppendLine($" {TableHeaderColumn} {TableColumnSeperator} {TableHeaderColumn} {TableColumnSeperator} {TableHeaderColumn} ");

                foreach (var log in logDetails.Where(l => l.Item1 == LogLevel.Error))
                {
                    report.AppendLine($" {log.Item2.EntryTime} {TableColumnSeperator} {log.Item2.Heading} {TableColumnSeperator} {log.Item2.Message} ");
                }

                #endregion

            }

            return report.ToString();
        }

        /// <summary>
        /// Output the report when flush is called
        /// </summary>
        public virtual void Flush()
        {
            try
            {
                var report = GenerateReport();

                // Dont want to assume locality here
                string logRunTime = _reportDate.ToString().Replace('/', '-').Replace(":", "").Replace(' ', ' ').Replace("  ", " ");

                string logFileName = string.Format("Transform Report {0} {1}", _reportFileName,
                    logRunTime);

                logFileName = logFileName + ".md";

                using (StreamWriter sw = new StreamWriter(logFileName, true))
                {
                    sw.WriteLine(report);
                }

                // Cleardown all logs
                var logs = _lazyLogInstance.Value;
                logs.RemoveRange(0, logs.Count);

                Console.WriteLine($"Report saved as: {Environment.CurrentDirectory}\\{logFileName}");

            }
            catch (Exception ex)
            {
                Console.WriteLine("Error writing to log file: {0} {1}", ex.Message, ex.StackTrace);
            }

        }
    }
}
